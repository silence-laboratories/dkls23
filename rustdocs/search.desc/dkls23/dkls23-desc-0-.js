searchState.loadedDescShard("dkls23", 0, "DKLs23 rust implementation\nSeed for our RNG\nVersion of domain labels\nReturn as slice of bytes\nCreate message ID for a broadcast message, without a ‚Ä¶\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nKey Export related functions and structs\nKey Import related functions and structs Module for ‚Ä¶\nDKLs23 keygen protocol\nCreate message ID for given instance id, sender, receiver ‚Ä¶\nMisc protocol helper functions.\nSetup message creation/parsing\nDKLs23 signing protocol\nSome party decided to not participate in the protocol.\nTag of an encypted keyshare message\nDistributed key generation errors\nMissing message\nWe can‚Äôt a send message\nHelper method to combine the secret shares into the ‚Ä¶\nDecrypt share encrypted by <code>export_keyshare()</code>\nExport keyshare.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGenerate message receiver map.\nReceive exported key shares, combine them and calculate ‚Ä¶\nCreate ecdsa keyshares from private key.\nSome party decided to not participate in the protocol.\nBig F vec mismatch\nBig S value mismatch\nFailed felman verify\nInvalid commitment hash\nInvalid DLog proof\nInvalid key refresh\nerror while serializing or deserializing or invalid ‚Ä¶\nInvalid Polynomial Point\nInvalid Quorum Change\nDistributed key generation errors\nMissing message\nNot unique x_i values\nPPRF error\nPublic key mismatch between the message and the party\nSeed for our RNG\nWe can‚Äôt a send message\nVarious contants\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nKey refresh protocol\nKeyshare and related definitions\nGenerate message receiver map.\nMigrate shares from GG20\nQuorum change protocol Quorum change protocol Based on ‚Ä¶\nExecute DKG protocol.\nMisc reusable code\nLABEL for the commitment 1\nLABEL for the commitment 2\nLABEL for the keygen protocol\nFirst tag available for user applications.  Use ‚Ä¶\nTag for P2P EndemicOTMsg1 message\nBroadcast message KeygenMsg1\nBroadcast message KeygenMsg2\nMessage handled by KeygenParty\nMessage handled by KeygenParty\nTag for final message to communicate result of keyshare ‚Ä¶\nLABEL for the DLOG proof 1\nLABEL for the DLOG proof 2\nLABEL to create dlog sessionID from final_session_id and ‚Ä¶\nLABEL for the quorum change commitment 1\nLABEL for the commitment 2\nLABEL for the quorum change protocol\nTag for P2P OT message 1\nTag for P2P OT message 2\nTag for P2P 1 message\nTag for P2P 2 message\nBroadcast message QuorumChangeMsg0\nBroadcast message QuorumChangeMsg1\nBroadcast message QuorumChangeMsg2\nKeyshare for refresh of a party.\nReturns the argument unchanged.\nDeserialize KeyshareForRefresh from bytes\nCreate KeyshareForRefresh struct from Keyshare\nCreate KeyshareForRefresh struct for the participant who ‚Ä¶\nCalls <code>U::from(self)</code>.\nlist of participants ids who lost their key_shares, should ‚Ä¶\nCreate new KeyshareForRefresh object.\nPart ID from key share\nPublic key of the generated key.\nRank of each party\nExecute Key Refresh protocol.\nset s_i to None if party_i lost their key_share\nThreshold value\nSerialize KeyshareForRefresh to bytes Used to send ‚Ä¶\nset s_i to None if party_i lost their key_share\nKey share of a party.\nIdentified of key share data\nReturn underlying byte slice.\nGet the big S value of another party\nDerive the child public key for a given derivation path\nGet the additive offset of a key share for a given ‚Ä¶\nDerive the extended public key for a given derivation path ‚Ä¶\nReturn user defined data embedded into the key share. The ‚Ä¶\nReturns the argument unchanged.\nCreate a key share from slice of bytes.\nCreate a key share from a given vector. Returns a passed ‚Ä¶\nGet the fingerprint of the root public key\nReturn rank of a party.\nCalls <code>U::from(self)</code>.\nAllocate an instance of a key share with given parameters.\nReturn public key as ProjectiveProint.\nReturn vector of ranks\nReturns root chain code\nReturns public key as ProjectivePoint\nReturn the secret scalar s_i.\nx_i_list\nReturn true if all parties has rank zero.\nMigrate from GG20 shares to DKLS23 shares. Same logic as ‚Ä¶\nGenerate message receiver map.\nExecute Quorum change protocol.\nA wrapper for a message of type T with support for in-place\nRepresents an encryption scheme interface for in-place ‚Ä¶\nA type with fixed size of external representation.\nSize of the message header.\nExternal representation of a point on a curve\nSize of an external representation of Self\nExternal Scalar representation\nDefault encryption scheme\nA wrapper for a message of type T with support inplace ‚Ä¶\nA type with some external represention.\nCall a passed closure with a mutable reference to a ‚Ä¶\nReturns passed error if msg is a vaild abort message.\nCreate an Abort Message.\nDecode a value from <code>input</code> buffer using <code>size</code> bytes. Return ‚Ä¶\nEncode AffinePoint\nDecode a NonZeroScalar\nDecode ProjectivePoint\nDecode a scalar\nDecrypts the provided data buffer using associated data ‚Ä¶\nDecrypte message and return reference to the payload and ‚Ä¶\nDecrypt message and return references to the payload, ‚Ä¶\nEncode header parts into given buffer.\nEncode a value into passed buffer and return remaining ‚Ä¶\nEncode AffinePoint\nEncode ProjectivePoint\nEncode a scalar\nEncrypts the provided data buffer using associated data and\nEncrypt message.\nSize of external representation in bytes\nDecode flags field.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nUse existing buffer but make sure it has the right size.\nUse existing buffer but make sure it has the right size.\nDecode message id field.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAllocate a message with passed ID and TTL and additional ‚Ä¶\nAllocate a message with passed ID and TTL and additional ‚Ä¶\nAllocate a message with passed ID and TTL and additional ‚Ä¶\nReturn size of trailing segment. See method <code>encrypt()</code> and ‚Ä¶\nReturn a mutable reference to message payload object and ‚Ä¶\nReturn a mutable reference to message payload object and ‚Ä¶\nReturn a mutable references to message payload object, ‚Ä¶\nReturn external representation of own public key\nDeserialize value from given buffer\nSets or updates the public key for a specified receiver ‚Ä¶\nSing the message and return underlying byte vector.\nSize of the whole message with additional data and trailer ‚Ä¶\nSize of the whole message with additional trailer bytes.\nDefine a family of tags indexed by some parameter.\nDefine a familty of tags indexed by pair of parameters.\ntags\nConvert the tag to an array of bytes.\nDecode TTL field.\nVerify signed message and return a payload reference.\nVerify message in the passed buffer and return range ‚Ä¶\nVerify signed message and return a payload reference.\nSerialize a value into passed buffer\nAbort\nRelay Errors\ncustom message relay\nInvalidMessage\nRecv\nStructure to receive a round of messages\nSend\nAdd expected messages and Ask underlying message relay to ‚Ä¶\nAsk set of messages with a given <code>tag</code> from a set of <code>parties</code>.\nThe same as <code>ask_messages_from_iter()</code> by accepts slice of ‚Ä¶\nBroadcast 4 values and collect 4 values from others in the ‚Ä¶\nMark message with ID as expected and associate pair ‚Ä¶\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn underlying relay object\nConstruct a FilteredMsgRelay by wrapping up a Relay object\nCreate a new round with a given number of messages to ‚Ä¶\nReceiver all messages in the round, decrypt, decode and ‚Ä¶\nReceiver all messages in the round, verify, decode and ‚Ä¶\nIt is possible to receive a invalid message with a correct ‚Ä¶\nReceive an expected message with given tag, and return a ‚Ä¶\nReceive next message in the round. On success returns ‚Ä¶\nReceive broadcasted 4 values from all parties in the round ‚Ä¶\nCreate a round\nTag of a broadcast message indicating that sender won‚Äôt ‚Ä¶\nAn iterator for parties in range 0..total except me.\nAllow to pass Arc where expected SK: Signer\nA setup message for sign::finish()\nA setup message for a reciever of exported key.\nA setup message for key export.\nA setup message for keygen::run()\nType of a signature, added at end of all broadcast messages\nType to sign broadcast messages, some kind of SecretKey.\nType to verify signed message, a verifying key. AsRef&lt;u8&gt; ‚Ä¶\nType of empty signature.\nA verifying key for NoSignature. Verification always ‚Ä¶\nA setup message for sign::pre_signature()\nType that provides a protocol participant details.\nA setup message for quorum_change::run()\nByte representation of a signature.\nTag for all setup messages\nA setup message for sign::run()\nSupport for decoding/encoding signatures as bytes.\nSign the provided message bytestring using <code>Self</code> (e.g. a ‚Ä¶\nVerify the provided message bytestring using <code>Self</code> (e.g. a ‚Ä¶\nReturn iterator of all participant‚Äôs indexes except own ‚Ä¶\nKey chain path for this signature\nDerive key_id from a public_key.\nDerive key_id from a public_key.\nGet the length of this signature when encoded.\nExpected public key.\nSetup for Finish PreSignature\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEach execution of a distributed protocol requires a unique ‚Ä¶\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSetup for Key export\nSetup for DKG\nA shared reference to a Keyshare.\nA shared reference to a Keyshare.\nA shared reference to a Keyshare.\nAdditional data to incorpatate into resulting Keyshare.\nAdditional data to incorpatate into resulting Keyshare.\nHash of a message to sign.\nHash of a message to sign.\nReturn message Time To Live.\nGenerate ID of a message from this party to some other (or ‚Ä¶\nGenerate ID of a message from given sender to a given ‚Ä¶\nNew participant rank. Panics is <code>party_id</code> is out of range.\nreturn new_party_id by party_index\nList of indices of new parties in a list of protocol ‚Ä¶\nNew threshold parameter.\nA shared reference to a Keyshare.\nlist of old party indices\nReturn an index of the participant in a protocol. This is ‚Ä¶\nReturn a rank of a participat with given index. May panic ‚Ä¶\nReturn reference to participant‚Äôs own verifier\nPre-signature created by sign::pre_signature()\nAdditional data to incorpatate into resulting PreSignature.\nSetup for Quorum Change\nPrivate key to decrypt P2P messages.\nPublic key of a receiver party.\nSetup for DSG\nSign the given message and return a digital signature\nA signer to sign messages from the participant.\nThreshold parameter.\nEncode signature as its byte representation.\nReturn total number of participants of a distributed ‚Ä¶\nAttempt to sign the given message, returning a digital ‚Ä¶\nReturn a verifying key for a messages from a participant ‚Ä¶\nUse <code>Self</code> to verify that the provided signature for a given ‚Ä¶\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSetup message for key exporter\nSetup message for key export receiver\nSetup message for a key export .\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nKeyshare\nCreate new setup message\nUpdate TTL\nSetup message for a key receiver in a key export protocol.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate new setup message\nUpdate TTL\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSome party decided to not participate in the protocol.\nAbort the protocol and ban the party\nDSG variant\nFailed check\nFinish only\nSignPre + Finish\nInvalid commitment\nInvalid digest\nInvalid final_session_id\nInvalid message format\nInvalid PreSignature\nk256 error\nMaximum supported value for the recovery ID (inclusive).\nResult after pre-signature of party_i\nPreSign only\nRecovery IDs, a.k.a. ‚Äúrecid‚Äù.\nWe can‚Äôt a send message\nDistributed key generation errors\nECDSA/secp256k1 signature (fixed-size)\nECDSA/secp256k1 verification key (i.e. public key)\nfinal_session_id\nFinish DSG.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert a <code>u8</code> into a <code>RecoveryId</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDid the affine x-coordinate of ùëò√óùëÆ overflow the ‚Ä¶\nIs the affine y-coordinate of ùëò√óùëÆ odd?\nGenerate message receiver map.\nCreate a new <code>RecoveryId</code> from the following 1-bit arguments:\nExecute DSG upto creation of PreSignature.\nExecute DSG protocol.\nConvert this <code>RecoveryId</code> into a <code>u8</code>.\nGiven a public key, message digest, and signature, use ‚Ä¶\nGiven a public key, message, and signature, use trial ‚Ä¶\nGiven a public key, message digest, and signature, use ‚Ä¶")