searchState.loadedDescShard("sl_oblivious", 0, "Domain labels\nEndemic 1 out of 2 Oblivious Transfer\nRandom Vector OLE Implementation of the protocol 5.2 …\nSoft spoken Oblivious Transfer\nUtility functions\nzkproofs\nLABEL for All-but-One OT\nLABEL for All-but-One PPRF Hash\nLABEL for All-but-One PPRF\nLABEL for All-but-One PPRF Proof\nLABEL for Discrete Log Proof challenge\nLABEL for EndemicOT\nLABEL for RandomVOLE gadget vector\nLABEL for RandomVOLE mu\nLABEL for RandomVOLE theta\nLABEL for SoftSpokenOT expand seeds\nLABEL for SoftSpokenOT\nLABEL for SoftSpokenOT matrix hash\nLABEL for SoftSpokenOT randomize\nDomain labels version\nEndemicOT Message 1\nEndemicOT Message 2\nEndemicOTReceiver 1 out of 2 Endemic OT Fig.8 …\nSender of the Endemic OT protocol. 1 out of 2 Endemic OT …\nExternal representation of a point on a curve\nThe output of the OT receiver.\nThe output of the OT sender.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>ReceiverOutput</code>.\nCreate a new instance of the EndemicOT receiver.\nProcess EndemicOTMsg1 from OTReceiver\nDomain separation lavbel\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new label.\nMessage output in RVOLE protocol\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new RVOLE receiver\nAbort the protocol and ban the Receiver\nThe extended output of the OT receiver.\nThe extended output of the OT sender.\nSoftSpokenOT errors\nImplements BuildPPRF and ProvePPRF functionality of Fig.13 …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSimple trait to extract a bit from a byte array.\nCustom extension trait for the merlin transcript.\nAppend a point to the transcript.\nAppend a scalar to the transcript.\nGet challenge as scalar from the transcript.\nExtract a bit at given index (in little endian order) from …\nNew transcript for DLOG proof\nNon-interactive Proof of knowledge of discrete logarithm …\nGet fiat-shamir challenge for Discrete log proof.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nProve knowledge of discrete logarithm.\nChallenge response\nPublic point <code>t</code>.\nVerify knowledge of discrete logarithm.")